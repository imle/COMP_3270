algorithm-1 (A: Array [1 ... n] of integer)
1       smallest := nil
2       ind_l := nil
3       ind_r := nil
4       current := 0
5       for i := 1 to (n-1)
6           for j := i to (n-1)
7               for k := i to j
8                   current := current + A[k]
9               if smallest = nil or smallest > current
10                  smallest := current
11                  ind_l := i
12                  ind_r := j
13              current := 0
14      return (smallest, ind_l, ind_r)



algorithm-2 (A: Array [1 ... n] of integer)
1       negatives := []
2       m = 0
3       for i := 1 to (n-1)
4           if A[i] < 0
5               negatives.append(i)
6               m = m + 1
7           if A[i] < smallest
8               smallest := A[i]
9               ind_l := i
10              ind_r := i
11      smallest := nil
12      ind_l := nil
13      ind_r := nil
14      current := 0
15      for i := 1 to (m-1)
16          for j := i to (m-1)
17              for k := negatives[i] to negatives[j]
18                  current := current + A[k]
19              if smallest = nil or smallest > current
20                  smallest := current
21                  ind_l := i
22                  ind_r := j
23              current := 0
24      return (smallest, ind_l, ind_r)



algorithm-3 (A: Array [l ... r] of integer)
1       smallest_ending_here := 0
2       ind_l_ending_here := nil
3       smallest := 0
4       ind_l := nil
5       ind_r := nil
6       has_negative := false
7       for i := 1 to (n-1)
8           if A[i] < 0
9               has_negative := true
10              break
11          if A[i] < smallest
12              smallest := A[i]
13              ind_l := i
14              ind_r := i
15      if !has_negative
16          return (smallest, ind_l, ind_r)
17      for i := 1 to (n-1)
18          smallest_ending_here = smallest_ending_here + A[i]
19          if smallest_ending_here > 0
20              smallest_ending_here = 0
21              ind_l_ending_here = i + 1
22          if smallest > smallest_ending_here
23              smallest := smallest_ending_here
24              ind_l := ind_l_ending_here
25              ind_r := i
26          if smallest > A[i]
27              smallest := A[i]
28      return (smallest, ind_l, ind_r)