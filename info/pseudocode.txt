algorithm-1 (A: Array [1 ... n] of integer)
1       smallest := nil
2       ind_l := nil
3       ind_r := nil
4       current := 0
5       for i := 1 to (n-1)
6           for j := i to (n-1)
7               for k := i to j
8                   current := current + A[k]
9               if smallest = nil or smallest > current
10                  smallest := current
11                  ind_l := i
12                  ind_r := j
13              current := 0
14      return (smallest, ind_l, ind_r)



algorithm-2 (A: Array [1 ... n] of integer)
1       negatives := []
2       m = 0
3       for i := 1 to (n-1)
4           if A[i] < 0
5               negatives.append(i)
6               m = m + 1
7       smallest := nil
8       ind_l := nil
9       ind_r := nil
10      current := 0
11      for i := 1 to (m-1)
12          for j := i to (m-1)
13              for k := negatives[i] to negatives[j]
14                  current := current + A[k]
15              if smallest = nil or smallest > current
16                  smallest := current
17                  ind_l := i
18                  ind_r := j
19              current := 0
20      return (smallest, ind_l, ind_r)



algorithm-3 (A: Array [l ... r] of integer)
    smallest_ending_here := 0
    ind_l_ending_here := nil
    ind_r_ending_here := nil

    smallest := 0
    ind_l := nil
    ind_r := nil

    for i := 1 to (n-1)
        smallest_ending_here = smallest_ending_here + A[i]

        if smallest_ending_here > 0
            smallest_ending_here = 0
            ind_l_ending_here = i + 1
            ind_r_ending_here = ind_l_ending_here

        if smallest > smallest_ending_here
            smallest := smallest_ending_here
            ind_l := ind_l_ending_here
            ind_r := i

        if smallest > A[i]
            smallest := A[i]

    return (smallest, ind_l, ind_r)